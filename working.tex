%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[11pt, twocolumn]{article}

\usepackage[a4paper,margin=25mm]{geometry}
\usepackage{csquotes}
\usepackage[sorting=none,backend=bibtex]{biblatex}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{cleveref}

\bibliography{lib}
\newcommand{\picalc}{\(\pi\)-calculus }

% \usepackage{verbments}   % For python code highlighting, as used in the dissertation.
% For dissertation code samples, I used the block: 
% \begin{pyglist}[language = python, encoding = utf8, caption = {Python function objects can be passed and run, like a function pointer}, listingname=\textbf{Code Sample}, numbers=left]

% Code here!

% \end{pyglist}
% But I'm sure you have your own solution, just putting this here if you want something similar to the dissertation's highlighting.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{Simulating Variance in Socio-Technical Workflows using Process Fuzzing}

\author{Tom Wallis and Tim Storer}

% \date{}    Do we want a date on the paper? Don't know how these things are done. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{abstract}
%Variation on the abstract from the dissertation?
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Modelling and simulating in large scale, complex socio-technical systems
engineering projects is an on-going research challenge.  Existing methods and
notations are largely derived from a classical engineering abstract, reduce, and
refine technique.  Unfortunately, these principles are confounded by
socio-technical systems problems, which resist the separation of concerns
necessary for abstraction and reduction.  As a consequence, modelling
socio-technical systems using these techniques will typically either result in a
model that is tractable, but lacks the necessary detail of the underlying system
to provide informative results; so narrow in scope as to be uninformative about
the behaviour of the wider system of interest; or so large and complex as to be
intractable for analysis.

A critical aspect of these challenges is the non-determinism and variance in
behaviour exhibited by socio-technical systems.

This variance may be caused by a variety of factors including natural
variability in human decision making, external pressures on the system, such as
loss of resources,...

This paper presents a novel approach to simulating and measuring the effect of
variance in socio-technical behaviours on overall system performance.  Systems
are modelled as collections of idealised workflows, constructed from a modular
toolkit of actions for a problem domain.  Properties for good outcomes.

  These workflows are then subjected to
`fuzzing' in order to simulate the effects of variance in the system.

The rest of this paper is structured as follows

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Related Work}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\label{related_head}
Herrmann \& Loser\cite{Herrmann1999} discuss sociotechnical modelling with inherent vagueness, and while this might be shown to be a useful construct, it doesn't address the problem that sociotechnical modelling with uncertainty of action is difficult to model. Instead, Herrmann \& Loser create sociotechnical models using pictorial representations -- but these may be difficult to fuzz programmatically. Therefore, a comparison of current methods for representing sociotechnical systems and introducing variance was necessary. \par

\subsection{Modelling System Requirements}\label{planning_modelling_requirements}
The modelling system desired had some properties that could not be found in the available alternatives. For example, the models had to be procedural, but also easy to write and maintain. For reasons laid out below, Python was the most suitable choice. \par

The language had to be powerful, because the system would need to be capable of creating potentially complex models. The fact that Python is a very powerful, very portable language that allows for readable codebases at scale was a strong influencing factor when deciding what language would suit the construction of a sociotechnical system. Another feature of the models that needed to be implemented was that they must be modular. Python allows for the creation of modules and packages that makes it easy to bring a workflow written for a subsection of a system and integrate it into a larger model of that system. \par

A lesson learned from research on i* (found at \cref{research_istar}) was that the interactions between different people makes a big difference to the end result of the sociotechnical simulation to be built. Therefore, in an effort to simplify the models needed to test the hypothesis, our modelling system need not be capable of modelling multiple concurrent actors. 

\subsubsection{Currently existing platforms}
As a result of the desire to create programmatic models to mutate, it was decided that any pictographic approach would add unnecessary complications. Then, if variance is shown to be modelled successfully using code fuzzing, this technique could then be applied to pictographic methods. \par

\subsubsection{KaOS} 
KaOS is a goal-oriented modelling technique for sociotechnical systems modelling\cite{Werneck2009}. This seemed like an appropriate place to begin, as KaOS is heavily used and cited in the academic community. The actors we model are attempting to achieve or fulfil some goal, so surely this is an appropriate place to start researching current modelling techniques.\par%Goal-oriented model
%Our actors are ultimately trying to fulfil some goal, so surely goal-orientation is what we want?
However, there are some issues with KaOS for the purposes of our models. For one, KaOS is useful if one must elicit software engineering requirements from a client, but in terms of modelling human actors, KaOS is less widely used. Requirements engineering techniques would be inappropriate for a model we intend to fuzz, even if a representation of the goals might also be mutatable. \par 
Ideally these models should be easily verifiable by a human, so either a graphical or human-readable textual format would be good to represent these, but KaOS lends itself well to graphical representations that seemed hard to execute as some simulation. Therefore, while widely taught and used, KaOS doesn't meet our requirements for modelling. \par
%Widely used and seemingly popular for academic purposes -- good if we wanted to do future work or get interest in the project!
%KaOS is often used in Requirements Engineering, and we're really interested in workflow modelling, so maybe best to look elsewhere.

\subsubsection{i*} %TODO
\label{research_istar}
i* is another technique that, while useful for gaining an insight into some sociotechnical system, is ill-suited to our needs as a result of its requirements engineering background\cite{Werneck2009}. In i*, actors rely on each other for goals and responsibilities to be fulfilled. i* therefore represents a better social model for a system than some of its competitors, and is widely cited and popular in the academic community, similar to KaOS. Both are used in situations as different as software engineering\cite{Almisned2010}, artificial intelligence\cite{VanDiggelen2010}, and even comes up in journals for infectious diseases\cite{Tutorial2007}. \par
%Actor intent model
%We're putting stress on actors, so this is interesting.
As a result of i*'s better social modelling than KaOS, we get a slightly different look a sociotechnical modelling and requirements engineering. However, as widely cited and interesting as i* might be, it suffers the same fundamental flaws that KaOS does, the largest of which being its lack of workflow modelling. It is clear to see that interactions between people is an important component of any sociotechnical modelling platform, however. Due consideration should be given as to the social implications in a sociotechnical model and whether any sociotechnical stresses that arise from the social interaction would be useful for this project. \par
%Used for requirements engineering?
%Not really workflow-oriented, which is what we want, but actor orientation is interesting, because we're modelling the actions of people, rather than their goals. Therefore, this tells us something about the system we ultimately want to find/create.

\subsubsection{YAWL} %TODO
YAWL was particularly interesting because of its focus on workflow. YAWL, which stands for Yet Another Workflow Language\cite{TerHofstede2010}, is a workflow modelling platform with its own tools, which are sophisticated and multi-platform. The creators of YAWL also have interests in areas such as \picalc\cite{Aalst2004}, which makes YAWL interesting for the additional reason that it has some mathematical backing in its representation of workflows. With this said, the lead authors have also published work stating that workflows are much more than simple \picalc processes\cite{Aalst2004}. \par

While workflow is our main concern when searching for candidates to perform fuzzing on, YAWL is largely constructed with a graphical tool, making it difficult to find things to mutate. Ergo, YAWL would be inappropriate as a candidate for fuzzable systems. However, it does get us closer to the modelling system we require, and shows that there is some academic interest in workflow-oriented modelling systems. \par
%Actually a workflow language!
%Graphical
%has a multi-platform editor but maybe not best for our purposes

% Can probably be cut or be very reduced.
\subsubsection{OBASHI}
OBASHI\cite{ObashiMethodology} is a modelling system that focuses on business processes instead of sociotechnical models. However, OBASHI's business process modelling techniques focus on dataflow, meaning that systems have states that get changed as a simulation occurs. OBASHI also focuses on simplicity in its models, which is something that would be required by a sociotechnical modelling framework to ensure that the models created for this project would be at least moderately accurate representations of the systems as a whole. Given that dataflow and workflow have clear correlations, it might be prudent for a fuzzable sociotechnical platform to separate its own concerns by using layered models. \par 

Indeed, focusing away from the academic perspective, many modelling systems are used commercially that are not open to scientific analysis. Few pieces of academic literature exist at all for OBASHI, despite its 15 year existence. It may be prudent to learn from insights into what works in the practically-minded setting of modelling in the private sector. An appropriate way to prune the methods to research would be to observe those that have lasted in a changing technological landscape. Therefore, due attention should be paid to OBAHSI's layered dataflow models, as this would help separate concerns in the modelling system being created, as it does in the OBASHI setting. \par

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%   TOM HAS EDITED TO HERE SO FAR AND HAS MORE TO GO, BUT MUST STUDY. MORE TOMORROW, HOPEFULLY.   %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsection{Code Fuzzing for Sociotechnical Variance}
Little academic research appears to have been done on programmatically inserting sociotechnical variance. A little work has been done into systems for \emph{Punctuated Socio-Technical Information System Change model}s\cite{Lyytinen2008}, but this appears to refer more to the way information systems alter over time and less to do with the study of uncertainty in information systems. \par
Other research has been done into the management of organisational uncertainty\cite{Grote2004}\cite{Herrmann1999}, which appears to be ideal for the task at hand. Unfortunately, no sociotechnical simulations with uncertainty injected into the models created could be found. \par
Therefore, while sociotechnical modelling is now a well-established field with competing methodologies, and sociotechnical uncertainty has also been a research subject since as early as 1976\cite{Susman1976}, no programmatic sociotechnical modelling has been documented which models sociotechnical stress as a component of that model. Therefore, the hypothesis of the project is clear; that is, to construct such a system and attempt to verify that sociotechnical stress can be introduced to the system by means of code fuzzing. \par

\subsubsection{Introducing Variance}
\label{Variance_research}
Currently, variance must be introduced to a programmatic model by hand. That is, as a construction of a model, we must build the sociotechnical stress into the model rather than applying it after the model has been created. \par

\subsubsection{Graphical representations and UML}
\label{pictorial}
Pictorial representations of sociotechnical systems can be very human-readable, which makes them suitable candidates for creating a sociotechnical model. Modelling systems such as OBASHI\cite{ObashiMethodology} use graphical representations of sociotechnical systems to build models of business and IT processes, but build these models using dataflow. To contrast, a UML Use Case diagram\cite{Omg2010} models an actor within a larger system to visualise a sociotechnical system. Both models use graphical representations of the systems they model to make the complexity of the model easy for a human to parse, but these models can be difficult for a computer to parse. \par
UML tries to overcome this by being equally readable by a computer: frameworks like the Eclipse Modelling Framework can generate Java code from a UML class diagram, for example\cite{EMFManual}. UML also succeeds in creating a standard for colloquial "flowcharts" by creating well-defined specifications such as the UML Activity Diagram. Therefore, using UML as a format for laying out a sociotechnical system that can be easily created and read by humans, but is also easily computer-parsable, seemed to be an appropriate way to create the programmatic models.

\subsection{Fuzzing Library Requirements}\label{planning_fuzzing}
Having researched what was already available in the academic and commercial spaces, it was decided after some deliberation that the best option was to define our own modelling system and create our own fuzzing library.  \par 
The fuzzing library desired also had unique properties that made it difficult to find an equivalent for in a commercial or academic setting. \par
The fuzzing library was of particular importance because the main study of the project was on variance in sociotechnical systems. Therefore, the fuzzing library had a particularly strict set of requirements. the fuzzing library needed to have fairly precise control over the activity of the mutations, because the mutations it introduced needed to be representative of sociotechnical stress. Ideally, it would be possible that the mutation testing would not be a black box, so that the exact nature of the sociotechnical stress could be discerned. Therefore, if a custom library was not to be made, then the chosen library would need to be open sourced. \par
It transpired that the library would need to be built to spec anyway, because the library needed to generate different mutations on every call to the functions it was fuzzing. This meant that not only would specific parts of the procedural model need to be targeted, but the library would either have to intercept function calls somehow or fuzz the function to randomly select one of many fuzzed versions of itself at execution time. This functionality was \emph{critical}, because human variance in a workflow is to change the behaviour in some random way every time that behaviour is executed. With flows and atoms acting as blueprints for behaviour, these blueprints would need to be altered when enacted, just as in real life, to make a meaningful simulation. No available code fuzzing library could be found that could do fuzzing during the execution of the fuzzed program, so a custom library needed to be built. \par
With the fuzzing library being such a critical part of the research, none of these points could be compromised on. In addition, a custom built library would allow fuzzing methods to adapt and grow as the modelling method matured. Therefore, a custom fuzzing library was made. \par

\subsubsection{Existing Fuzzing Platforms}
\label{research_fuzzing}
Because the systems we were interested in creating were to be self-documenting, we chose Python as a language to write our models in. Python's clarity combined with the ease of quickly writing working Python code meant that self-documenting models could be feasibly made. In addition, Python supplied language features such as decorators and a built in Abstract Syntax Tree library that made it an ideal candidate. \par
We therefore set about finding appropriate fuzzing libraries in Python, and found several:
\subsubsection{Sulley}
\label{fuzzing_sulley}
Sulley is a fuzzing library for Python which is popular for remote application and protocol fuzzing. Sulley alters the protocol by which it inserts data into an application or system, and observes how that application reacts to the altered input, to simulate problems with networks and human users. It is under active development, and is open sourced.\par
While using a popular, open-source library for inspiration when creating our own mutation system, Sulley was inappropriate for our needs.\par
Sulley fuzzes by way of changing protocols and inputs to some system it interacts with. We felt that altering inputs to that system lacked the degree of control that changing workflows directly would provide. Technically, it would be possible to get around this problem by creating models in some remote program that took instructions from some fuzzed input, but we felt that this additional degree of abstraction would lower the self-documenting nature of our models and would be an impractical modelling technique anyway. \par

\subsubsection{Fusil}
\label{fuzzing_fuzil}
Fusil was another fuzzing library that was investigated. Fusil allows for fuzzing the environment of a python program, which made it appealing to us. While environmental factors impact the sociotechnical model however, these factors are unrelated to the properties Fusil is capable of monitoring. \par
Fusil is able to create mangled files as fuzzed/invalid input to a program, monitors and limits CPU and memory usage, and checks logs for system errors and other signs that a fuzzed program was not functioning correctly under adverse circumstances. This seemed appealing, because monitoring performance under adverse circumstances is precisely our goal in this project. \par
Unfortunately Fusil also did not meet our requirements: it monitors the effect of a change in computational environment on a program, where we are interested in the effect of the change of a social environment on a workflow. While our workflows are being modelled as programs, this does not mean that the workflows themselves would be being altered, so stress on a sociotechnical system still wouldn't be being modelled. Fusil was a further worse choice when taking into account the fact that we would not be able to pinpoint the errors that were being introduced by observing memory and CPU usage, and other computational concerns. \par
Therefore, we could not use Fusil as our fuzzing system of choice. \par

\subsubsection{MutPy} 
\label{fuzzing_mutpy}
From the MutPy package page\cite{MutPy26:online}: 
\begin{displayquote}
MutPy is a mutation testing tool for Python 3.x source code. MutPy supports standard unittest module, generates YAML reports and has colorful output. It’s apply mutation on AST level. You could boost your mutation testing process with high order mutations (HOM) and code coverage analysis.
\end{displayquote}\par

It seemed that MutPy supplied \emph{everything} required. This would be beneficial, but unfortunately, MutPy had a relatively large and complex codebase\cite{khala8:online} that made it hard to modify for the specific requirements of the research. In addition, relying on a complex dependency that is designed for unit testing seemed to be a bad approach, as research interests might not align with MutPy's maintainers' in the future. As a result, it might have been necessary to fork their codebase at the time and maintain our own version for research purposes; this approach was not future-proof, and so an alternative approach was deemed necessary. \par

Working in MutPy's favour, however, was that it was a \emph{code fuzzing} rather than protocol fuzzing library. Particularly, it fuzzed source code to a similar end as something like Java's PiTest\cite{PITMu92:online}. This was more in line with our goals, although MutPy still didn't deliver what was required from a code fuzzing library for this experiment. Therefore, it was decided to learn from MutPy's strong points and implement something similar, but from a fresh, maintainable codebase with interests more aligned with that of the research. This would also allow for potential improvements to be implemented in the future, which could not be determined before modelling began; as it happens, this decision turned out to pay off, as additional functionality was needed. \par

\subsubsection{PyMuTester}
\label{fuzzing_pymutester}
PyMuTester\cite{GitHu12:online} proved to be the closest to the library required, though it still fell short in some areas. Particularly, PyMuTester did not appear to have many types of mutation it could enact. \par
PyMuTester did not have a large codebase\cite{GitHu12:online}, nor did it have very much functionality to offer, but it offered mutation via Abstract Syntax Tree editing. The decision was made to study the PyMuTester source as a template for a code fuzzing library of a new design. PyMuTester seemed to be much too immature as a library to base the whole project around, and was last updated in October 2014. However, it did show promise, and gave a basis around which writing a code mutation library could be built, while also taking cues from the more advanced source of MutPy\cite{khala8:online}.  \par%\cite{} PyMuTester source at https://github.com/miketeo/PyMuTester       \cite{} MutPy's source at https://bitbucket.org/khalas/mutpy/src


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Socio-Technical Workflow Fuzzing}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In this section we introduce our approach to modelling idealised workflows in
socio-technical systems and then introducing variance in their execution through
fuzzing.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Workflow Modelling}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Types of Behaviour Fuzzing}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Sequence Truncation

Step re-ordering

Incorrect branch selection

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Illustrative Example - Software Development}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\printbibliography

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}