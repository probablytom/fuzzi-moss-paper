%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[11pt, twocolumn]{article}

\usepackage[a4paper,margin=25mm]{geometry}
\usepackage{csquotes}
\usepackage[sorting=none,backend=bibtex]{biblatex}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{cleveref}

\bibliography{lib}
\newcommand{\picalc}{\(\pi\)-calculus }

% \usepackage{verbments}   % For python code highlighting, as used in the dissertation.
% For dissertation code samples, I used the block: 
% \begin{pyglist}[language = python, encoding = utf8, caption = {Python function objects can be passed and run, like a function pointer}, listingname=\textbf{Code Sample}, numbers=left]

% Code here!

% \end{pyglist}
% But I'm sure you have your own solution, just putting this here if you want something similar to the dissertation's highlighting.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{Simulating Variance in Socio-Technical Workflows using Process Fuzzing}

\author{Tom Wallis and Tim Storer}

% \date{}    Do we want a date on the paper? Don't know how these things are done. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{abstract}
%Variation on the abstract from the dissertation?
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Modelling and simulating in large scale, complex socio-technical systems
engineering projects is an on-going research challenge.  Existing methods and
notations are largely derived from a classical engineering abstract, reduce, and
refine technique.  Unfortunately, these principles are confounded by
socio-technical systems problems, which resist the separation of concerns
necessary for abstraction and reduction.  As a consequence, modelling
socio-technical systems using these techniques will typically either result in a
model that is tractable, but lacks the necessary detail of the underlying system
to provide informative results; so narrow in scope as to be uninformative about
the behaviour of the wider system of interest; or so large and complex as to be
intractable for analysis.

A critical aspect of these challenges is the non-determinism and variance in
behaviour exhibited by socio-technical systems.

This variance may be caused by a variety of factors including natural
variability in human decision making, external pressures on the system, such as
loss of resources,...

This paper presents a novel approach to simulating and measuring the effect of
variance in socio-technical behaviours on overall system performance.  Systems
are modelled as collections of idealised workflows, constructed from a modular
toolkit of actions for a problem domain.  Properties for good outcomes.

  These workflows are then subjected to
`fuzzing' in order to simulate the effects of variance in the system.

The rest of this paper is structured as follows

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Related Work}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\label{related_head}
Herrmann \& Loser\cite{Herrmann1999} discuss sociotechnical modelling with inherent vagueness, and while this might be shown to be a useful construct, it doesn't address the problem that sociotechnical modelling with uncertainty of action is difficult to model. Instead, Herrmann \& Loser create sociotechnical models using pictorial representations -- but these may be difficult to fuzz programmatically. Therefore, a comparison of current methods for representing sociotechnical systems and introducing variance was necessary. \par

\subsection{Modelling System Requirements}\label{planning_modelling_requirements}
The modelling system desired had some properties that could not be found in the available alternatives. For example, the models had to be procedural, but also easy to write and maintain. For reasons laid out in the library implementation section\cref{planning_fuzzing}, Python was the most suitable choice. \par

However, the modelling system itself still needed to be designed. Particularly, the system needed to allow for large codebases, that were readable, and also to permit modularity and package systems that allowed different parts of the model to be seperated out for their own development. While Python provides support for these features, the modelling system itself needed to take these requirements into account.  \par

\subsubsection{Currently existing platforms}
As a result of the desire to create programmatic models to mutate, it was decided that any pictographic approach would add unnecessary complications. Then, if variance is shown to be modelled successfully using code fuzzing, this technique could then be applied to pictographic methods. \par

\subsubsection{KaOS} 
KaOS is a goal-oriented modelling technique for sociotechnical systems modelling\cite{Werneck2009}. This seemed like an appropriate place to begin, as KaOS is heavily used and cited in the academic community. The actors we model are attempting to achieve or fulfil some goal, so surely this is an appropriate place to start researching current modelling techniques.\par

However, there are some issues with KaOS for the purposes of our models. For one, KaOS is useful if one must elicit software engineering requirements from a client, but in terms of modelling human actors, KaOS is less widely used. Requirements engineering techniques would be inappropriate for a model we intend to fuzz, even if a representation of the goals might also be fuzzable. \par 

\subsubsection{i*}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TIMTIMTIMTIMTIM I feel like this is worth keeping because the citations are interesting, but I also feel like it's an obvious candidate to cut from the section. Maybe integrating with the KaOS one. This subsection feels too long though. Thoughts?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\label{research_istar}
%i* is another technique that, while useful for gaining an insight into some sociotechnical system, is ill-suited to our needs as a result of its requirements engineering background\cite{Werneck2009}. In i*, actors rely on each other for goals and responsibilities to be fulfilled. i* therefore represents a better social model for a system than some of its competitors, and is widely cited and popular in the academic community, similar to KaOS. Both are used in situations as different as software engineering\cite{Almisned2010}, artificial intelligence\cite{VanDiggelen2010}, and even comes up in journals for infectious diseases\cite{Tutorial2007}. \par
%As a result of i*'s better social modelling than KaOS, we get a slightly different look a sociotechnical modelling and requirements engineering. However, as widely cited and interesting as i* might be, it suffers the same fundamental flaws that KaOS does, the largest of which being its lack of workflow modelling. It is clear to see that interactions between people is an important component of any sociotechnical modelling platform, however. Indeed, literature suggests that any component of a sociotechnical system can greatly influence its operation\cite{Crabtree2000}. \par

\subsubsection{YAWL} %TODO
YAWL was particularly interesting because of its focus on workflow. YAWL, which stands for Yet Another Workflow Language\cite{TerHofstede2010}, is a workflow modelling platform with its own tools, which are sophisticated and multi-platform. The creators of YAWL also have interests in areas such as \picalc\cite{Aalst2004}, which makes YAWL interesting for the additional reason that it has some mathematical backing in its representation of workflows. With this said, the lead authors have also published work stating that workflows are much more than simple \picalc processes\cite{Aalst2004}. \par

While workflow is our main concern when searching for candidates to perform fuzzing on, YAWL is largely constructed with a graphical tool, making it difficult to find things to mutate. Ergo, YAWL would be inappropriate as a candidate for fuzzable systems. However, it does get us closer to the modelling system we require, and shows that there is some academic interest in workflow-oriented modelling systems. \par
%Actually a workflow language!
%Graphical
%has a multi-platform editor but maybe not best for our purposes

% Can probably be cut or be very reduced.
\subsubsection{OBASHI}
OBASHI\cite{ObashiMethodology} is a modelling system that focuses on business processes instead of sociotechnical models. However, OBASHI's business process modelling techniques focus on dataflow. OBASHI also focuses on simplicity in its models, which it creates by saperating concerns using a layered modelling strategy. This simplified model with separated concerns was similar to what was needed, even if dataflow and workflow modelling are not fundamentally similar fields. \par 

Few pieces of academic literature exist at all for OBASHI, despite its 15 year existence; yet it may be prudent to learn from insights into what works in the practically-minded setting of modelling in the private sector. \par

\subsection{Code Fuzzing for Sociotechnical Variance}
Little academic research appears to have been done on programmatically inserting sociotechnical variance. A little work has been done into systems for \emph{Punctuated Socio-Technical Information System Change model}s\cite{Lyytinen2008}, but this appears to refer more to the way information systems alter over time and less to do with the study of uncertainty in information systems. \par

Other research has been done into the management of organisational uncertainty\cite{Grote2004}\cite{Herrmann1999}, which appears to be ideal for the task at hand. Unfortunately, no sociotechnical simulations with uncertainty injected into the models created could be found. \par

Although sociotechnical uncertainty has been studied since as early as 1976\cite{Susman1976}, no programmatic sociotechnical modelling has been documented which models sociotechnical stress as a component of that model. Therefore, the hypothesis of the project is clear; that is, to construct such a system and attempt to verify that sociotechnical stress can be introduced to the system by means of code fuzzing. \par

\subsection{Fuzzing Library Requirements}\label{planning_fuzzing}
%%%%%%%%%%%%%%%Okay to leave this blank?%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%The fuzzing library desired also had unique properties that made it difficult to find an equivalent for in a commercial or academic setting. \par

%The fuzzing library was of particular importance because the main study of the project was on variance in sociotechnical systems. Therefore, the fuzzing library had a particularly strict set of requirements. The fuzzing library needed to have fairly precise control over the activity of the mutations, because the mutations it introduced needed to be representative of sociotechnical stress. In addition, these mutations had to change every time a part of the system operated, so that activity in a system was analogous to repeating an action: an actor may make different mistakes in different iterations of a workflow. \par

\subsubsection{Existing Fuzzing Platforms}
\label{research_fuzzing}
Because the systems we were interested in creating were to be self-documenting, we chose Python as a language to write our models in. Python's clarity combined with the ease of quickly writing working Python code meant that self-documenting models could be feasibly made. In addition, Python supplied language features such as decorators and a built in Abstract Syntax Tree library that made it an ideal candidate. \par
We therefore set about finding appropriate fuzzing libraries in Python:

\subsubsection{MutPy} 
\label{fuzzing_mutpy}
From the MutPy package page\cite{MutPy26:online}: 
\begin{displayquote}
MutPy is a mutation testing tool for Python 3.x source code. MutPy supports the standard Python unittest module, generates YAML reports and has colorful output. It’s apply mutation on AST level. You could boost your mutation testing process with high order mutations (HOM) and code coverage analysis.
\end{displayquote}\par

Unfortunately, MutPy had a relatively large and complex codebase\cite{khala8:online} that made it hard to modify for the specific requirements of the research. In addition, relying on a complex dependency that is designed for unit testing seemed to be a bad approach, as research interests might not align with MutPy's maintainers' in the future. As a result, it might have been necessary to fork their codebase at the time and maintain our own version for research purposes; this approach was not future-proof, and so an alternative approach was deemed necessary. \par

In line with our goals was that MutPy supplied a code fuzzing system, although MutPy still didn't deliver what was required for this experiment. Therefore, it was decided to learn from MutPy's strong points and implement something similar, but from a fresh, maintainable codebase with interests even more aligned with that of the research. \par

\subsubsection{PyMuTester}
\label{fuzzing_pymutester}
PyMuTester\cite{GitHu12:online} proved to be the closest to the library required, though it still fell short in some areas. Particularly, PyMuTester did not appear to have many types of mutation it could enact. \par

PyMuTester did not have a large codebase\cite{GitHu12:online}, nor did it have very much functionality to offer, but it offered mutation via Abstract Syntax Tree editing. The decision was made to study the PyMuTester source as a template for a code fuzzing library of a new design. PyMuTester seemed to be much too immature as a library to base the whole project around, and was last updated in October 2014. However, it did show promise, and gave a basis around which writing a code mutation library could be built, while also taking cues from the more advanced source of MutPy\cite{khala8:online}. \par


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Socio-Technical Workflow Fuzzing}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In this section we introduce our approach to modelling idealised workflows in
socio-technical systems and then introducing variance in their execution through
fuzzing.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Workflow Modelling}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Types of Behaviour Fuzzing}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Sequence Truncation

Step re-ordering

Incorrect branch selection

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Illustrative Example - Software Development}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\printbibliography

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}