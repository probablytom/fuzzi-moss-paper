%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass{sig-alternate}

\usepackage[T1]{fontenc}

\usepackage[lighttt]{lmodern}

\usepackage[british]{babel}%
\usepackage{cleveref}%
\usepackage{csquotes}%
\usepackage[shortcuts]{extdash}%
\usepackage[numbers]{natbib}


\usepackage{listings}
\usepackage{subcaption}

\lstset{language=python}
\lstset{basicstyle=\tt\small}
\lstset{keywordstyle=\ttfamily\bfseries}

\newenvironment{FunctionList}{%
\lstset{basicstyle=\ttfamily\bfseries\small}
\begin{list}{}{\leftmargin=5pt}
}{\end{list}\lstset{basicstyle=\ttfamily\small}}

\newcommand{\picalc}{\(\pi\)-calculus }

\hyphenation{poli-cies}
%\hyphenation{tech-ni-cal}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{Simulating Variance in Socio-Technical Behaviours using Workflow Fuzzing}

%\author{Tom Wallis \and Tim Storer}

% \institute{Tom Wallis
%   \at School of Computing Science, University of Glasgow, Glasgow \\
%   \email{twallisgm@gmail.com}
%   \and
%   Tim Storer
%   \at School of Computing Science, University of Glasgow, Glasgow \\
%   \email{timothy.storer@glasgow.ac.uk}
%   }  
  
% \date{Received: XXX / Accepted: XXX}

% \date{}    Do we want a date on the paper? Don't know how these things are done. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{abstract}
  The engineering of large scale, complex software based socio-technical systems
  is still very much a craft, dependent on methods based on trial, error and
  subsequent revision.  A particular difficulty is the lack of modelling tools
  that support the analysis of actor behaviours in and around socio-technical
  systems.  Existing notations such as activity diagrams, business process
  modelling languages or petri nets assume that behaviour can be described as
  idealised work flows.  Unfortunately, the behaviour in a socio-technical
  system is highly contingent and subject to considerable variability as actors
  react to changing conditions and identify potential optimisations to their
  practices.  As a consequence, existing techniques result in models that either
  lack sufficient detail to capture the effect of subtle contingencies; are too
  narrow to make useful assessments about the larger system; are unable to
  capture evolution in behaviours; or are so complex that analysis and
  interpretation becomes intractable.

  This paper presents Fuzzi Moss, a novel method for simulating the effect of
  contingent behaviour in socio-technical systems using software code fuzzing.
  A socio-technical system is defined as an object-oriented domain model
  compromising one or more classes.  Behaviours that operate on the system model
  state are described separately as a set of idealised executable work flows.
  These work flows are then annotated with code fuzzers, declarations of how the
  work flow could be dynamically altered (removing steps, duplicating steps,
  introducing new steps for example) when the work flow is executed.  A
  simulation is then configured by executing the fuzzed work flow on an instance
  of the domain model.  Results collected from the domain model state inform
  predictions as to how an idealised work flow will perform in the presence of
  contingent behaviour.
 
  We have implemented a proof of concept tool to evaluate our method. Fuzzi Moss
  is as a small Python library, comprising decorators for annotating workflows
  with desired fuzzers, a mechanism for dynamically inspecting the structure of
  a work flow and applying fuzzers during execution and a library of core
  fuzzers.  We evaluate our approach to simulating socio-technical behaviours by
  applying Fuzzi Moss to a socio-technical system case study.  The results of
  the case study demonstrate the feasibility of the fuzzing method.  Finally, We
  explore the wider applications of fuzzing in socio-technical systems modelling
  and discuss the next steps for the research.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}
\label{sec:introduction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Modelling and simulating in large scale, complex socio-technical systems
engineering projects is an on-going research challenge \citep{baxter08learning}.
A socio-technical system is characterised by the interactions between a variety
of actor types within the system's scope, including individual huamn operators,
organisational units and technical artifacts
\citep{Susman1976,elhassan07role,sommerville08socio}. These systems also
incorporates a complex variety of structures and that direct or influence actor
and system behaviour, including workflow descriptions, organisational
hierarchies, regulatory or legal standards, organisational policies and culture,
nterpersonal relationships and actor responsibilities
\citep{bade07structures,pentland05organisational}. Examples of such systems with
complex workflows involving multiple actors, include emergency vehicle dispatch
\citep{robinson96limited}, electronic voting systems
\citep{bryans04towards,lock07observations}, patient care in a neo-natal unit
\citep{baxter07evaluating}; and electronic stock exchange infrastructures
\citep{cftc-sec10findings}.  Systems of this form confound traditional
approaches to modelling, simulating and predicting behaviour for several
reasons.

\begin{itemize}

\item Socio-technical systems are typically very large, constituted of many
  hundred or thousands of autonomous actors and components, each with their own
  behaviour that may be influenced by other actors in the system
  \cite{crabtree00ethnomethodologically}.  This simultaneous intrinsic
  complexity makes refinement, reduction and abstraction, the conventional tools
  of managing scale, difficult to apply, since individual behaviours are
  difficult to classify and aggregate.  One study has advocated the
  re-conception of systems engineering methods based on the analogy of city
  maintenance, rather than system construction \citep{feiler06ultra}, although
  no methods are presented for making this transition.

\item The behaviour is contingent on unpredictable circumstances, including both
  factors in the environment; and concerning the system actors.  For example,
  the time and manner in which a task, such as developing a new feature for a
  software system, is completed may vary considerably between actors with
  different training and experiences.  Similarly, the decision to work on a task
  at all may depend on unpredictable and uncontrollable external circumstances
  (such as a power outage).  In these circumstances, actors may take it upon
  themselves to complete tasks outwith expected workflows in order to discharge
  their responsiblities, by working from a nearby office, or cafe, even if this
  may violate organisational security policies.  As \citet{besnard03human} note,
  such adaptations often make the human actors the dependable parts of
  socio-technical systems.

\item Behaviour is continually evolving, as the autonomous actors in a system
  adapt to new circumstances, discover optimisations to their workflows, adapt
  the workflow to suit local organisational priorities or take shortcuts
  \citep{bonen79evolutionary,Lyytinen2008,anderson04heterogeneous}.  As a
  consequence, the \emph{defacto} behaviour exhibited within a system may differ
  from that envisaged by system architects in idealised workflows.  For example,
  a ward manager in a hospital may delay releasing beds for re-allocation by
  wider hospital management in the anticipation that these will be required by
  incoming patients later in the day \citep{dewsbury07responsibility}.  This
  evolution may quickly invalidate expected models of behaviour.

\end{itemize}

As a consequence, modelling socio-technical system behaviours using conventional
techniques will typically either result in a model that is tractable, but lacks
the necessary detail of the underlying system to provide informative results; so
narrow in scope as to be uninformative about the behaviour of the wider system
of interest; or so large and complex as to be intractable for analysis, whether
manual or automated.

The contribution of this paper is to present and evaluate a novel approach to
simulating variance in socio-technical behaviours on overall system performance,
based on the automated \emph{fuzzing} of workflow descriptions.  The paper
presents a method for describing socio-technical systems as object-oriented
domain models, implemented in the Python programming language.  These models are
manipulated by system actors, who are directed by idealised workflow
descriptions, encoded as collections of Python functions.  Workflow variance is
simulated by automatically and dynamically fuzzing the workflow descriptions
using code fuzzing.

A proof of concept fuzzing library, Fuzzi Moss is developed and presented.  To
evaluate the proposed approach an example case study, software development
workflows was created using Fuzzi Moss.  The case study compares the
performance of different software development processes (resources
expended, features implemented and system quality) when following idealised
workflows and when following workflows that have been subject to code fuzzing
induced variance.

The rest of this paper is structured as follows.  Section \ref{sec:related}
discusses related work, covering existing techniques for modelling
socio-technical workflows and other applications of code fuzzing in software
engineering.  Section \ref{sec:fuzzi-moss} presents the method for constructing
models of socio-technical systems, associated workflows and denoting desired
fuzzings.  Where relevant, this section also discusses details of the
implementation detalis for Fuzzi Moss.  Section \ref{sec:evaluation} presents
the case study evaluation of the method and Section \ref{sec:conclusions}
discusses future work and conclusions.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Related Work}

\label{sec:related}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This section presents a literature review of the development of models and
simulations of behaviours in socio-technical systems.  This section highlights
the difficulties of developing modelling techniques that accommodate the
inherent scale, complexity, contingency and dynamism of socio-technical systems.
Graphical notations have received considerable attention, perhaps due to their
perceived efficacy in communicating requirements between users, customers and
system architects.  These modelling languages include include workflow based
approaches including UML activity diagrams \citep{omg2010omguml}, BPML
\citep{White2004}, YAWL \citep{hofstede2010yawl} and OBASHI
\cite{obashimethodology}; and goal based approaches such as KaOS
\citep{Werneck2009}, i* \citep{yu1995} and responsibility modelling
\citep{sommerville09responsibility}.

Activity diagrams are perhaps the most commonly known workflow language, due to
incorporation in the UML standard \citep{omg2010omguml}.  The notation supports
the modelling of the flow of control across a directed graph of activiites, with
arcs representing transitions in control.  Additional nodes are provided for
denoting entry and exit points, as well as decision branches.  The notation is
based on the Petri Net formalism and includes support for concurrent flows
through the chart, as well as workflow forking and merging. The semi-formal
nature of the UML standard enable the automatic parsing of graphical models,
using CASE tools such as the Eclipse Modelling Framework \citep{EMFManual}.  An
advantage of this approach is that models can be used for negotiation between
project stakeholders, whilst also being used for simulations to predict system
behaviour.

The Business Process Model and Notation (BPMN) is an alternative OMG standard
for modelling workflows, with similar core notation and semantics for modelling
workflows \citep{omg2011omgbpmn}.  Unlike activity diagrams, however, BPMN
provides a richer notation for expressing more complex aspects of activities,
such as differentiating between tasks, activities and transactions; triggering
and orchestrating concurrent activiites using messages; the identification of
information resources need to realise an activity; and the orchestration of
activities across organisational boundaries \citep{White2004}.  The notation is
intended to support the generation of executable business processes expressed as
web services, however, it can also be employed in other workflow contexts.

Yet another workflow language (YAWL) provides similar capabilities to activity
diagrams for modelling workflows, as well as being supported by CASE tools for
graphical modelling \citep{hofstede2010yawl}.  However, unlike activity diagrams,
YAWL is based on the \picalc\citep{Aalst2004}.  The notation also provides for a
richer range of workflow requirements than activity diagrams, including
sophisticated forking and merging rules, separation between workflow
specfications and executions and resourcing and data requirements.

The OBASHI (Ownership, Business, Application, System, Hardware, Infrastructure
methodology and notation \citep{obashimethodology} is designed for modelling
business processes across enterprise infrastructures.  The notation is intended
for capturing the movement of data through a business process and revealing the
associated dependencies on underlying infrastructure such as software systems,
servers and network communications.  The language also provides a means for
mapping these flows to higher level concerns, such as business rationale and
ultimate organisational owner. In contrast to other workflow notations, flows
are based on the movement of data rather than control.

%%%%

Describing socio-technical behaviours using workflow notations can be difficult,
because of the basic assumption that all contigencies in a workflow can be
completely described at a given level of granularity, and that more complex
details can be encapsulated within coarser grained activities with well defined
interfaces.  However, as argued in Section \ref{sec:introduction},
socio-technical behaviours are inherently complex, contingent and evolutionary,
making such refinement based techniques difficult to apply.  As
\citet{israilidis13ignorance} have argued, the unknowns in a socio-technical
system may be far more significant than the knowns.Several authors have
therefore discussed alternative techniques for modelling socio-technical systems
with support for contingent behaviour
\citep{yu1995,dardenne93goal,Herrmann1999,sommerville09deriving}.

Both \citet{yu1995} and \citet{dardenne93goal} are goal oriented notations for
modelling socio-technical systems \citep{Werneck2009}.  In contrast to workflows,
goal oriented approaches primarily capture the intents of actors (what they are
seeking to achieve).  Goals can be de-composed into a sub-goal hierarchy using
logical operators to express the form of decomposition. Goals can also be
annotated with strategies and/or resource requirements to support automated
analysis.  \citeauthor{yu1995} argued that socio-technical systems should be
viewed as collections of collaborating actors, each with their own (potentially
conflicting) objectives.  Elciting and analysing the actors intents allows the
inter-dependencies between actors and the overall behaviour of the system to be
understood, without the need for explicit models of individual workflows. vents.

Other authors have extended goal oriented approaches to provide greater
flexibility.  \citet{sommerville09deriving} argued that stakeholders often
struggle to express their behaviour within a socio-technical system in terms of
goals.  Instead, \citet{sommerville09deriving} argued that the concept of
\emph{responsibility}, the duties held by an actor in a system, are a more
intuitive means of describing system behaviours that also capture a variety of
contingent behaviours.  They provide a notation for expressing the relationships
between responsibilities and resources in order to identify dependencies within
a system.  Earlier work on responsibility modelling also provided mechanisms
with annotating responsibilities with indicative workflows, expressing the means
by which responsibilities \emph{could} be executed.

Despite providing for contingency, a limitation of the goal and responsibility
approach is the need for complete model descriptions. \citet{Herrmann1999}
introduced techniques for annotating goal oriented system models in the SeeMe
notation with vagueness.  The notation enables a modeller to denote where
vagueness may be present in a model due to abstraction (i.e. consistent
vagueness) and due to ommission (inconsistent vagueness).  In addition,
\citeauthor{Herrmann1999} provide notation for indicating that a model is
thought to be complete, containing all pertinent details.  However, the
annotations are not accompanied by a formal semantics, or other means of
supporting automated analysis.

We are not aware of other applications of fuzzing techniques to modelling
contingent behaviours in socio-technical systems.  However, software code
fuzzing (or mutation) is employed in software quality assurance in order to
automatically generate program variants.  Mutation operators may alter the value
of literals, swap arithmetic or other operators, or change the ordering of
arguments to a function call, for example.  Applying different combinations of
mutation operators creates a population of mutants of the target program.  One
application of this technique is mutation testing, in which the generation of
program variants is used to simulate the introduction of defects and evaluate
the effectiveness of an application's test suite in detecting regressions
\citep{demillo78hints}.  A test is considered to have detected a mutant if the
application of the test to the mutant fails.  A test suite that detects a higher
proportion of mutants is considered to have good coverage of the target program.

The effectiveness of mutant generation is significantly influenced by choice of
defect operators to apply, since the search space of potential mutants to be
tested is very large and many mutants will reveal the same test suite
deficiencies \citep{takanen08fuzzing}..  Generation of mutants based on an
understanding of a system's specification allows defect generation to be focused
on a system's intended behaviour.  It can therefore be expected that applying
code fuzzing to simulating socio-technical behaviours requires an understanding
of the likely variants to behaviour that may occur in a workflow in order to
generate realistic simulations.

There are a variety of existing tools that incorporate fuzzing functionality,
including PiTest \citep{coles14pitest} for Java and MutPy \citep{mutpy26} and
PyMuTester \citep{pymuttester} for Python.  \citet{storer15ringneck-repos} has
also developed a tool for mutation testing component assembly
specifications. All these tools work by constructing and then manipulating
abstract syntax trees of target programs.  The result is a suite of statically
generated mutant programs that can be evaluated using the target program's own
test suite.  A disadvantage of this mechanism (for the purposes of modelling
socio-technical systems) is that the mutants are generated statically, prior to
program execution.  Our own implementation of code fuzzing is motivated by the
desire to simulate dynamic contingent behaviour, that can vary from the
idealised model each time a fuzzed step in a workflow is executed.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Method and Implementation}
\label{sec:fuzzi-moss}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In this section we introduce our approach to modelling idealised workflows in
socio-technical systems and then introducing variance in their execution through
dynamic fuzzing. The method comprises: construction of an object oriented model
of the problem domain; construction of an idealised representations of
socio-technical workflows that direct the specify the behaviours of actors in
the problem domain; annotation of the work flows with fuzzers to introduce
variance; execution of the workflows in scenarios; and measurement of outcomes
in the scenarios through observation of the problem domain state. Each stage of
the method is described in more detail below, using the task of developing
software as an illustrative example (we will present the full case study in
Section \ref{sec:evaluation}).

Implementation details of the the proof of concept library, Fuzzi Moss, are
also presented.  Source code for the Fuzzi Moss library is available from the
project's GitHub repository \citep{wallis2016fuzzi-moss-scm}.  The library was
implemented in the Python programming language.  The Python syntax is designed
to be readable, meaning that domain models and workflows could be expressed in
structured natural language.  Further, Python is an interpreted object-oriented
language, that treats function definitions as first class constructs.  This made
the development of a proof of concept fuzzing library straight forward.  The
core implementation is less than 100 lines of program code, including blank
lines and comments, whilst the library of utility fuzzers is implemented in less
than 300 lines. Source code for the case study is also available in a separate
GitHub repository \citep{storer2016softdev-workflow-scm}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Problem Domain Modelling}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The initial step in the fuzzi moss method is to develop a model of the target
socio-technical problem domain.  The model represents the invariant `physics' of
the problem domain that cannot be altered because it represent hard constraints
in the real world.  The model physics may represent constraints imposed by
natural laws, such as the conservation of energy; deliberate technical system
design, such as an access control client that limits access to a software system
to those who know an appropriate username and password combination; or emergent
phenomena, such as the tendency for the implementation of new features in a
software system to introduce bugs.

We have adopted an object-oriented approach to modelling the elements of the
problem domain \citep{bennett06object}, so that domain artifacts are represented
as instances of classes.  The state of a particular scenario in a problem domain
is therefore represented by a collection of inter-related Python objects
constructed from the classes specified in the domain model.  Figure
\ref{fig:feature-class-diagram} shows part of a class diagram for the software
development problem domain case study.  The diagram shows classes for system
feature (representing user-facing specifications of the system's functionality;
code chunks, representing the implementation details of the system and bugs
introduced into chunks during the completion of features.  Figure
\ref{fig:feature-instance-diagram} illustrates an example state for the same
problem domain using an object diagram, showing a feature implemented with two
chunks, one of which contains a bug.

\begin{figure}
  \centering

  \begin{subfigure}{\linewidth}
    \centering
    \includegraphics{floats/class-diagram-1}
    \caption{Class Diagram}
    \label{fig:feature-class-diagram}
  \end{subfigure}

  \begin{subfigure}{\linewidth}
    \centering 
    \includegraphics{floats/object-diagram-1}
    \caption{Object diagram}
    \label{fig:feature-instance-diagram}
  
  \end{subfigure}

  
  \caption{Object oriented models of a software development problem domain,
    using the UML notation.}

\end{figure}

The state of the problem domain can only be altered through explicit actions on
the domain (referred to as domain actions here), that are modelled as operations
on the domain classes.  In the example given in Figure \ref{fig:feature-class-diagram},
the state of a feature can be altered by invoking the \lstinline!extend()!
operation.  This adds a new chunk to the feature's implementation and also has
two side effects. The addition of new chunks may introduce bugs into the newly
created chunk, as well as create dependencies between the new chunk and other
chunks already in the system as a whole.  Consequently, operations are also
provided for refactoring (to reduce dependencies) and debugging (to remove bugs)
the feature.

Very few restrictions are placed on the design of the problem domain operations.
Operations can accept a variety of arguments, modify the class state, invoke
operations on other problem domain classes and return values as desired.
However The operations on the problem domain should be modelled as atomic and
independent, allowing them to be safely invoked in any combination.

The object oriented problem domain model is implemented as a collection of
Python classes.  Model state is represented by python instance attributes.
Operations are implemented as Python methods in the appropriate classes.
Problem domain classes can be extended with supplementary properties using the
Python \lstinline!@property! decorator in order to improve readability as
normal.  The state of the problem domain can therefore be accessed and read as
desired for measuring behaviour in scenarios, or instrumented to record relevant
events for later analysis.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Workflow Modelling}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The next stage of the method concerns the development of descriptions of
socio-technical behaviours of actors in the problem domain, called workflows.
These workflows orchestrate the sequence of actions by an actor on the artifacts
in the problem domain.  Behaviours are modelled as \emph{idealised} work flows,
i.e. the behaviour desired or expected of an actor in a socio-technical system
without concern for contingencies.  Workflows are modelled as activity diagrams,
which enables the construction of a hierarchy of workflow descriptions,
supporting modularity and reuse.  

Two related work flows are illustrated in Figure \ref{fig:workflow-partial}.
Figure \ref{fig:workflow-tdd} illustrates a Test Driven Development workflow, in
which a software developer specifies an implementation, creates a test case,
implements and debugs the feature and finally refactors the functional
implementation.  Figure \ref{fig:workflow-refactoring} illustrates the more fine
grained workflow for refactoring.  A developer, continues to refactor the
feature until the measured coupling rate is less than a desired maximum.  Both
workflows are executed by invoking operations on a \lstinline!Developer!
instance.

\begin{figure*}
  \centering

  \begin{subfigure}[b]{.45\linewidth}
    \centering
    \includegraphics{floats/tdd-workflow-1}

    \caption{Test driven development}
    \label{fig:workflow-tdd}
  \end{subfigure}
  \begin{subfigure}[b]{.45\linewidth}
    \centering
    \includegraphics{floats/refactoring-workflow-1}
    
    \caption{Refactoring}
    \label{fig:workflow-refactoring}
  \end{subfigure}
  
\

  \caption{Partial socio-technical workflows for software development expressed
    as UML activity diagrams.}

  \label{fig:workflow-partial}
\end{figure*}

We currently limit the use of activity diagram notation to begin, end, activity
and conditional branches, with transitions indicating the flow of control
between steps.  Fuzzi Moss does not currently support concurrent behaviours that
would be represented by fork and join nodes, although this feature is discussed
in Section \ref{sec:future-work}.


The workflow models are implemented as collections of Python functions.  As for
the domain actions, implementation of the workflow functions is
flexible. Workflow functions can be parameterised as and may also return values
as desired.  Workflow functions can be encapsulated into classes to support
model maintenance, although this is not necessary for the method itself.  One
restriction that is made is that workflow functions should not contain nested
function definitions, as these may be inadvertently fuzzed by the Fuzzi Moss
mechanism.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Specifying the Fuzzers for a Workflow}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The workflow functions implemented in Python are denoted as eligible for fuzzing
by applying the \lstinline!@fuzz! decorator provided in the Fuzzi Moss
package. The decorator's constructor accepts one argument, a pointer to a
\emph{fuzzer} function, that will be used in the fuzzing mechanism described
below.  Python's decorator mechanism intercepts invocations of the decorated
function and allows these to be substituted with an alternative function to be
invoked.  The Fuzzi Moss decorator exploits this mechanism by defining and
returning a \lstinline!wrap()!  function that is able to dynamically fuzz the
decorated function each time it is invoked.  The wrap function accepts the same
set of arguments as the decorated function and should be expected to return the
same values. The decorator's \lstinline!__call__()!  method, which intercepts
the invocation of the decorated function, defines the wrap function as follows.

\begin{enumerate}

\item The abstract syntax tree (AST) for the decorated function is constructed,
  using the Python \lstinline!inspect! package to recover the function's source
  code and the \lstinline!ast!  package to build the AST from the source.  This
  reference AST is then cached for future reference.

\item A copy of the AST is made.  An AST visitor (called a transformer) is then
  constructed and given the decorator's fuzzer attribute as an argument.  The
  copied syntax tree is then passed to the visitor.

\item The visitor identifies the function definition node in the AST and applies
  the fuzzer to the function definition's body.  The body is represented as a
  list of Python statements in the AST.  The function body is replaced by the
  value returned by the fuzzer.

\item Finally, the now fuzzed AST is compiled to Python byte code.  The byte
  code of the fuzzed function is then substituted for the decorated function's
  byte code and the function is invoked with its original parameters.  Control
  is then passed back to the Python interpreter, allowing any returned values to
  be passed back as normal.

\end{enumerate}

An example of the application of a fuzzer (identity) is shown in Figure
\ref{fig:fuzz}.

 \begin{figure}
   \centering
  \begin{lstlisting}
@fuzz(identity)
def _refactor_feature(developer, feature):
    while len(feature.dependencies) > \
        self.target_dependencies_per_feature:
        developer.refactor(feature)
  \end{lstlisting}
  
  \caption{Example fuzz decorator applied to a software development workflow.}
  \label{fig:fuzz}
\end{figure}

The generic definition of the fuzzer function (accept and return a list of
Python statement ASTs) allows a user to define a wide range of fuzzing
mechanisms to suit their problem domain.  In addition, a suite of fuzzers is
also provided with Fuzzi Moss that allow the modular construction of more
complex fuzzer behaviours.  The behaviour of each of the fuzzers available in
Fuzzi Moss are described in the following sub sections.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Simple Fuzzers}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

A simple fuzzer accepts and returns a list of \lstinline!ast.Statement! objects
and can be declared for use directly within a fuzz decorator.  The following
simple fuzzers are defined in Fuzzi Moss.

\begin{FunctionList}

\item\lstinline!identity! returns the input list of statements.  The identity
  fuzzer is used as a default for the fuzz decorator, but is also useful when
  building composite fuzzers.

\item\lstinline!replace_steps_with_passes! returns a list of \lstinline!pass!
  statements of the same length as the input.  Replacing statements with pass is
  safer than removing the statement, since a Python function must be defined
  with at least one statement.

\item\lstinline!duplicate_steps! returns a list containing the input sequence
  repeated twice.

\item\lstinline!shuffle_steps! returns a randomly shuffled list of the input.  A
  Python Random object \lstinline!fuzzi_moss_random! is used as a random source.

\item \lstinline!swap_if_blocks! switches the body and orelse blocks of all if
  statements in the input.

\end{FunctionList}

We have already seen the application of simple fuzzers in Figure \ref{fig:fuzz}.
Note that the fuzzer is supplied to the fuzz decorator as a function pointer,
rather than as an evaluated function call.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Fuzzing Filters}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Sometimes it is desirable to restrict the application of simple fuzzers to
particular portions of the body of a workflow function.  In this situation the
\lstinline!filter_steps()! fuzzer can be used.  Filter steps takes two
arguments: a filter function pointer and a fuzzer function pointer.  These are
used to define a nested \lstinline!_filter_step! fuzzer that behaves like a
fuzzer as described above.

The filter fuzzer accepts a list of statements and returns a list of tuples.
Each tuple defines gives the start and end index for a block in the input.  Each
block is then fuzzed using the supplied fuzzer.  Blocks not specified by the
filter are not affected by the fuzzer, such that the returned sequence of
statements may contain a mix of fuzzed and un-fuzzed statements.

The following filters are available for use in conjunction with a fuzzer.

\begin{FunctionList}

\item \lstinline!choose_last_step! returns the start and end index of the last
  statement in the input, i.e. \lstinline!input[-2:-1]!

\item \lstinline!choose_random_steps(n)!  returns $n$ length 1 sub-blocks
  randomly selected from the input steps.

\item \lstinline!exclude_control_structures(target)! permits the exclusion of
  control structure statements by type as specified by the target input
  argument. Supported structures are \lstinline!for!, \lstinline!while!,
  \lstinline!if!, \lstinline!try!-\lstinline!except! and \lstinline!return!.

\end{FunctionList}

Several pre-defined filtering fuzzers are implemented in Fuzzi Moss combining
some of the predefined filters and simple fuzzers.  These provide commonly
required fuzzers, including removing or duplicating the last step or a random
step. A \lstinline!choose_identity! filter is also included for completeness.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Composite Fuzzers}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

More complex fuzzers can be assembled using composite fuzzing functions that are
implemented in a similar manner to filtering.  


\begin{FunctionList}
\item \lstinline!in_sequence(fuzzers)! applies each fuzzer found in the input
  list of fuzzers in sequence to a function body.

\item \lstinline!choose_from(distribution)! selects a fuzzer to apply at random
  from the supplied probability distribution.  The distribution is defined as a
  list of weight, fuzzer tuples.

\item \lstinline!on_condition_that(condition, fuzzer)! %
  applies the specified fuzzer if the specified condition holds.  The condition
  may be a literal boolean value, a function pointer or a Python expression.
  Lambda expressions are not supported.

\item \lstinline!recurse_into_nested_steps(target_structures)! identifies
  control structure statements and applies the supplied fuzzer to their body
  blocks.  The recursion can be limited to particular control structures using
  the option \lstinline!target_structures! argument.
\end{FunctionList}

An example of applying a composite fuzzer to a workflow is shown in Figure
\ref{fig:composite}.  The figure shows a workflow for enhancing the quality of a
software system.  A developer adds a test to a feature in order to detect the
presence of bugs, or prevent the introduction of bugs during refactoring.  The
developer then performs some debugging work, followed by some refactoring.  The
fuzzer applied to the workflow is the \lstinline!choose_from!.  The supplied
distribution will fuzz the workflow 5\% of the time on average, removing one
step at random when it does so.  The figure therefore shows a convenient way of
modelling the occasional random omission of steps in a workflow.

\begin{figure}
  \centering

\begin{lstlisting}
@fuzz(
  choose_from([
    (0.95, identity),
    (0.05, remove_random_step)
  ])
)
def _enhance_system_quality(
    self, feature, developer):

    developer.add_test(feature)
    self._debug_feature(developer, feature)
    self._refactor_feature(developer, feature) 
\end{lstlisting}
  
  \caption{Application of a composite fuzzer to a workflow.}
  \label{fig:composite}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Control Structure Fuzzers}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The final set of fuzzers provide for manipulation of control structure
conditions and iterators.  Both of these fuzzers inspect the input list of
statements for compatible statement types to fuzz and apply the fuzzing to every
one found.

\begin{FunctionList}

\item \lstinline!replace_condtion_with(condition)! replaces conditions
  discovered in control structure statements with the specified condition.  The
  condition may be a literal boolean value, a function pointer or a Python
  expression defined in a string.  Lambda expressions are not supported.

\item \lstinline!replace_for_iterator_with(iterator)! replaces iterators
  discovered in for loops with the specified iterator.  The replacement iterator
  must be specified as a list containing numerical or string literal types only.

\end{FunctionList}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Defining Experiments}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Experiments in Fuzzi Moss are created by defining initial scenarios for 

The Fuzzi Moss package exposes variables in that can be used to configure the
global behaviour of the fuzz decorator, specifically:

\begin{itemize}
\item A Python random object, \lstinline!fuzzi_moss_random! is exposed.  This
  object is used as a source of randomness where required by the Fuzzi Moss
  fuzzers.  The object can be seeded or even completely replaced as desired by
  the modeller.

\item A boolean variable, \lstinline!enable\_fuzzings! is provided, which can be
  used to control whether fuzzings are applied.  This feature is useful for
  executing the fuzzed workflows in their idealised state, since this provides
  for comparison with fuzzed workflows.

\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Evaluation}
\label{sec:evaluation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Conclusions}
\label{sec:conclusions}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Future work ideas from Tom's dissertation.

Also, what about an aspect oriented approach.

\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\bibliographystyle{abbrvnat}
\bibliography{lib}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\end{document}